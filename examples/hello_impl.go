// Code generated by protoc-gen-thrift.
// source: hello.proto
// DO NOT EDIT!

/*
This thrift interface description was generated from from one more protobuf descriptors.

It is generated from these files:
	hello.proto

It has these top-level structs:
	HelloRequest
	HelloReply
*/
package hello

import thrift_pkg "github.com/golang/protobuf/examples/thrift"
import context "context"

// Reference imports to suppress errors if they are not otherwise used.
var _ = context.Background

func conv_HelloRequest_to_thrift(msg *HelloRequest) *thrift_pkg.HelloRequest {
	if msg == nil {
		return nil
	}
	thriftMsg := &thrift_pkg.HelloRequest{}

	thriftMsg.Ints = conv_pb_ᐸᐳint32_to_thrift_ᐸᐳint32(msg.Ints)
	thriftMsg.Amap = conv_pb_mapᐸint32ᐳint32_to_thrift_mapᐸint32ᐳint32(msg.Amap)

	thriftMsg.Arg = &thrift_pkg.HelloRequestArg{}
	switch x := msg.Arg.(type) {
	case *HelloRequest_Name:
		val := x.Name
		thriftMsg.Arg.Name = &val
	case *HelloRequest_Age:
		val := int32(x.Age)
		thriftMsg.Arg.Age = &val
	case *HelloRequest_Blip:
		thriftMsg.Arg.Blip = conv_HelloReply_to_thrift(x.Blip)
	case nil:
	// The field is not set.
	default:
		// TODO: unexpected type ???
	}

	return thriftMsg
}

func conv_HelloRequest_to_pb(msg *thrift_pkg.HelloRequest) *HelloRequest {
	if msg == nil {
		return nil
	}
	pbMsg := &HelloRequest{}

	pbMsg.Ints = conv_thrift_ᐸᐳint32_to_pb_ᐸᐳint32(msg.Ints)
	pbMsg.Amap = conv_thrift_mapᐸint32ᐳint32_to_pb_mapᐸint32ᐳint32(msg.Amap)

	if msg.Arg != nil {
		if msg.Arg.Name != nil {
			u := &HelloRequest_Name{}
			u.Name = *msg.Arg.Name
			pbMsg.Arg = u
		} else if msg.Arg.Age != nil {
			u := &HelloRequest_Age{}
			u.Age = int32(*msg.Arg.Age)
			pbMsg.Arg = u
		} else if msg.Arg.Blip != nil {
			u := &HelloRequest_Blip{}
			u.Blip = conv_HelloReply_to_pb(msg.Arg.Blip)
			pbMsg.Arg = u
		}

	}

	return pbMsg
}

func conv_HelloReply_to_thrift(msg *HelloReply) *thrift_pkg.HelloReply {
	if msg == nil {
		return nil
	}
	thriftMsg := &thrift_pkg.HelloReply{}

	{
		val := msg.Message
		thriftMsg.Message = &val
	}
	{
		val := int32(msg.Integer)
		thriftMsg.Integer = &val
	}
	{
		val := msg.Bloop
		thriftMsg.Bloop = &val
	}

	return thriftMsg
}

func conv_HelloReply_to_pb(msg *thrift_pkg.HelloReply) *HelloReply {
	if msg == nil {
		return nil
	}
	pbMsg := &HelloReply{}

	if msg.Message != nil {
		pbMsg.Message = *msg.Message
	}
	if msg.Integer != nil {
		pbMsg.Integer = int32(*msg.Integer)
	}
	if msg.Bloop != nil {
		pbMsg.Bloop = *msg.Bloop
	}

	return pbMsg
}

func conv_thrift_ᐸᐳint32_to_pb_ᐸᐳint32(thriftSlice []int32) []int32 {
	pbSlice := make([]int32, len(thriftSlice))
	for i := 0; i < len(thriftSlice); i++ {
		pbSlice[i] = int32(thriftSlice[i])
	}
	return pbSlice
}

func conv_pb_ᐸᐳint32_to_thrift_ᐸᐳint32(pbSlice []int32) []int32 {
	thriftSlice := make([]int32, len(pbSlice))
	for i := 0; i < len(pbSlice); i++ {
		thriftSlice[i] = int32(pbSlice[i])
	}
	return thriftSlice
}

func conv_thrift_mapᐸint32ᐳint32_to_pb_mapᐸint32ᐳint32(thriftMap map[int32]int32) map[int32]int32 {
	pbMap := make(map[int32]int32, len(thriftMap))
	for key, val := range thriftMap {
		pbMap[int32(key)] = int32(val)
	}
	return pbMap
}

func conv_pb_mapᐸint32ᐳint32_to_thrift_mapᐸint32ᐳint32(pbMap map[int32]int32) map[int32]int32 {
	thriftMap := make(map[int32]int32, len(pbMap))
	for key, val := range pbMap {
		thriftMap[int32(key)] = int32(val)
	}
	return thriftMap
}

type GreeterImpl struct {
	Client GreeterClient
}

func (self *GreeterImpl) SayHello(in *thrift_pkg.HelloRequest) (*thrift_pkg.HelloReply, error) {
	req := conv_HelloRequest_to_pb(in)
	resp, err := self.Client.SayHello(context.Background(), req)
	return conv_HelloReply_to_thrift(resp), err
}
